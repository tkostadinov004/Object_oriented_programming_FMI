## Примери - теория

**1.** Ще се компилира ли следният код? Ако не, защо?
```c++
#include <iostream>

class A {
public:
    void f() const
    {
        g();
    }
    void g() const{}
};
```

**2.** Ще се компилира ли следният код? Ако не, защо?
```c++
#include <iostream>

class A {
public:
    void t() {}
    void foo() const
    {
        t();
    }
};
```

**3.** Кои от следните твърдения са верни (отбележете с **да** или **не** за всяко едно):
 - Можем да викаме в конструктор друг конструктор на същия клас;
 - Можем да имаме няколко деструктора и няколко конструктора;
 - Можем да имаме няколко деструктора, но само един конструктор;
 - Можем да имаме няколко конструктора, но само един деструктор;
 - Можем да имаме само един конструктор и само един деструктор;
 - Задължително трябва да имаме имплементирани от нас конструктор и деструктор в класа;
 - Ако си напишем конструктор с параметри, то дефолтния конструктор се запазва;
 - Ако си напишем конструктор с параметри, то за да ползваме дефолтния конструктор трябва да напишем и него.


**4.** Посочете грешките в кода:
```c++
#include <iostream>
class Point {
    int x;
    int y;

    Point(int x, int y) {
        x = x;
        y = y;
    }
};
int main()
{
    Point p1;
}
```

## Задачи

**1.** В една софтуерна компания се провежда турнир по белот с благотворителна цел.

Трябва да създадете клас **BelotTournament**, който да провежда турнира.
За да бъде проведен един турнир, трябва да има отбори от софтуерни инженери. Всеки отбор се състои от 2 софтуерни инженери. Всеки **софтуерен инженер** има име (низ с произволна дължина), позиция (низ с произволна дължина) и заплата (цяло число). 

Броят на отборите трябва да е четен и по-голям от 2. При опит да започне турнира с нечетен брой отбори, последният добавен отбор бива премахнат преди началото на турнира.

Когато имато достатъчно отбори, чиито участници са валидни, тогава турнирът може да започне. Отборите биват разпределени на случаен принцип. След това се провежда дуел между отборите. Един дуел може да има максимално 3 рунда, като първият отбор достигнал 2 победи, печели дуела. Един рунд се провежда като за всеки отбор се четат точки от конзолата, които се добавя към общите точки на отбора. Рунда печели отборът, който първи достигне число 151. Това се повтаря за всички печеливши отбори, докато не остане един единствен отбор, който е победител. Тъй като турнирът е с благотворителна цел, всеки от загубилите участници дарява 2% от заплатата си, а 1% дават на всеки от печелившия отбор. Да се пресметне колко пари е събрала фирмата от турнира за дарение.

**2.** Създайте клас `NumberSeries`, който моделира работата с числова редица. В конструктора на класа ще приемате цяло число - начална стойност на редицата (a_0) и указател към функция на преход, приемаща цяло число и връщаща цяло число (a_i = f(a_i-1)).

Трябва да имате следните функционалности:
* Генериране на i-то число от редицата.
* Проверка дали подадено число е част от редицата.
* Setter-и за нова начална стойност и нова функция на преход.

Генерирането на стойности трябва да бъде оптимизирано откъм скорост:
* За коректна работа с фунцкионалността за генериране на i-то по ред число, трябва да поддържате динамичен масив в класа, в който да пазите досега генерираните стойности.
* Ако числото вече е било генерирано, трябва да го върнете като резултат без да го генерирате повторно.
* Ако числото го няма в масива, генерирайте и добавете към масива всички числа, които липсват до a_i в редицата и върнете генерираната стойност. 
* Ако в масива няма достатъчно място, за да се съхранят новите стойности, преоразмерете го по подходящ начин.
* При set-ване на нова начална стойност или функция на преход, трябва да изтривате динамичния масив и да започвате процеса на запазване отначало.

Помислете как трябва да се handle-не коректно копирането на обекти от вашия клас.
