## Примери
**1.** Какво ще отпечата на екрана следният код?
```c++
#include <iostream>

int main()
{
	int a = 3, b = 7;
	int* ptrA = &a;
	int* ptrB = &b;

	std::cout << a << " " << b << std::endl;
	std::cout << *ptrA << " " << *ptrB << std::endl;

	int x = *ptrA;
	*ptrA = *ptrB;
	*ptrB = x;

	std::cout << *ptrA << " " << ptrB << std::endl;
	std::cout << a << " " << b << std::endl;
}
```
**2.** Каква е разликата между следните 4 функции?
```c++
#include <iostream>

int f(int a)
{
    a++;
    return a;
}
int g(int& a)
{
    a++;
    return a;
}
int h(int* a)
{
    a++;
    return *a;
}
int k(int* a)
{
    (*a)++;
    return *a;
}

int main()
{
    int a = 10, b = 10, c = 10, d = 10;
    f(a);
    std::cout << a << std::endl; 
    g(b);
    std::cout << b << std::endl;
    h(&c);
    std::cout << c << std::endl;
    k(&d);
    std::cout << d << std::endl;
}
```
**3.** Има ли грешки в следния код и ако да - какви?
```c++
#include <iostream>

struct Book
{
    double price;
    char genre;
    int copiesCount;
    bool isSoldOut;
};

bool areEqual(Book b1, Book b2)
{
    return b1.price == b2.price && 
        b1.genre == b2.genre && 
        b1.copiesCount == b2.copiesCount && 
        b1.isSoldOut == b2.isSoldOut;
}

void createBook(Book b)
{
    std::cin >> b.price >> b.genre >> b.copiesCount >> b.isSoldOut;
}

void printBook(Book b)
{
    std::cout << b.price << b.genre << b.copiesCount << b.isSoldOut;
}

int main()
{
    Book b;
    createBook(b);
    printBook(b);

    Book* bookPtr = &b;
    std::cout << bookPtr.genre;
}
```
## Задачи
**1.** Напишете функция, която приема символен низ и връща ново заделен символен низ, съдържащ само цифрите от подадения низ.
</br>
**Пример:** </br>
Вход:
```
)Lso!c6d%9ucpB*CED5su2DH%&7t4)*
```
Изход:
```
695274
```
**2.**  Напишете функция, която приема число K и два масива с произволен размер и връща нов масив с точна големина, съдържащ всички числа от двата масива, които се делят на K.
</br>
**Пример:** </br>
Вход:
```
3
[2, 8, 3, 15, 27]
[5, 9, 4]
```
Изход:
```
[3, 15, 27, 9]
```
**3.** Създайте структура, която представлява точка в двумерното пространство. Също така, реализирайте следните функции:
- четене от стандартния вход
- принтиране на стандартния изход
- разстояние между две точки
</br>

**4.** Създайте структура, която представлява фигурата триъгълник. Също така, реализирайте следните функции:
- четене от стандартния вход
- принтиране на стандартния изход
- пресмятане на обиколка
- пресмятане на лице
- връщане на типа на триъгълника спрямо страните му (равнобедрен, равностранен, разностранен)
- връщане на типа на триъгълника спрямо ъглите му (остроъгълен, правоъгълен, тъпоъгълен)
</br>

**5.** Напишете функция **map**, която приема масив *arr* от цели числа, за който е заделено точно количество памет, и указател към функция *func* (приемаща и връщаща цяло число). Нека
функцията map промени всеки елемент на *arr* с резултата от *func* за съответния елемент.
**Пример:** </br>
Код:
```cpp
int f(int a)
{
    return a * 2;
}

... map(...)
{
    ...
}

int main()
{
    map(..., f);
    или
    map(..., [](int a) {
        return a * 2;
    });
}
```
Вход:
```cpp
[1, 2, 3, 4, 5]

Ще подадем следната функция:
int f(int a)
{
    return a * 2;
}
```
Изход:
```
[2, 4, 6, 8, 10]
```
**6.** Напишете функция **filter**, която приема масив *arr* от цели числа, за който е заделено точно количество памет, и указател към *предикат* (функция, която приема цяло число и връща булева стойност) *pred*. Нека функцията задели памет за нов масив, който съдържа само тези елементи на *arr*, за които *pred* е истина. </br>
**Пример:** </br>
Код:
```cpp
bool pred(int a)
{
    return a % 2 == 0;
}

... filter(...)
{
    ...
}

int main()
{
    int* arr = filter(..., pred);
    ...
    delete[] arr;
}
```
Вход:
```cpp
[1, 2, 3, 4, 5]

Ще подадем следната функция:
bool pred(int a)
{
    return a % 2 == 0;
}
```
Изход:
```
[2, 4]
```
**7.** Напишете функция **partition**, която приема масив *arr* от *n* на брой цели числа, за който е заделено точно количество памет, и указател към *предикат* (функция, която приема цяло число и връща булева стойност) *pred*. Нека функцията размести елементите на масива, така, че той да може да бъде разделен на 2 продължителни части -  такава, която съдържа само тези елементи на *arr*, за които *pred* е истина, и такава, която съдържа само тези елементи на *arr*, за които *pred* е лъжа. </br>
Тоест, по-формално, трябва да разместите елементите на масива така, че да e изпълнено: </br>
```math
\begin{matrix}
\exists \: 0 \le i \lt n \text{  , такова, че:} \\
\forall \: 0 \le j \le i: \: pred(arr[j]) \: \: \: \land \: \: \: \forall \: i \lt k \lt n: \: \neg pred(arr[k])
\end{matrix}
```
**Пример:** </br>
Код:
```cpp
bool pred(int a)
{
    return a % 2 == 0;
}

... partition(...)
{
    ...
}

int main()
{
    partition(..., pred);
}
```
Вход:
```cpp
[1, 2, 3, 4, 5]

Ще подадем следната функция:
bool pred(int a)
{
    return a % 2 == 0;
}
```
Изход:
```
[2, 4, 3, 1, 5]
```

*Follow-up:* Подобна реализация на функцията partition, с малко модификации и връщаща индекса, при който е "границата", спрямо предиката, се използва в рекурсивния алгоритъм за сортиране **quicksort**.
